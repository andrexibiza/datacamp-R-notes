?strptime
install.packages(naniar)
install.packages("naniar")
install.packages("naniar")
# Load packages
library(palmerpenguins) # data source
library(tidyverse)
library(dplyr)
library(naniar)
install.packages('naniar')
library(naniar)
install.packages("naniar")
install.packages('Rtools')
install.packages('naniar')
install.packages("naniar")
install.packages(c("BH", "bslib", "cli", "cpp11", "crosstalk", "curl", "data.table", "DBI", "dbplyr", "digest", "dplyr", "evaluate", "fansi", "future", "future.apply", "ggplot2", "glue", "haven", "htmltools", "htmlwidgets", "jsonlite", "knitr", "later", "lifecycle", "lubridate", "markdown", "openssl", "plotly", "prettyunits", "processx", "progress", "ps", "ragg", "Rcpp", "RcppArmadillo", "readr", "recipes", "reprex", "rlang", "sass", "scales", "stringi", "stringr", "systemfonts", "textshaping", "tidyr", "timechange", "timeDate", "tinytex", "tseries", "TTR", "utf8", "uuid", "vctrs", "vroom", "withr", "xfun", "xml2", "xts", "yaml"))
install.packages(c("BH", "bslib", "cli", "cpp11", "crosstalk", "curl", "data.table", "DBI", "dbplyr", "digest", "dplyr", "evaluate", "fansi", "future", "future.apply", "ggplot2", "glue", "haven", "htmltools", "htmlwidgets", "jsonlite", "knitr", "later", "lifecycle", "lubridate", "markdown", "openssl", "plotly", "prettyunits", "processx", "progress", "ps", "ragg", "Rcpp", "RcppArmadillo", "readr", "recipes", "reprex", "rlang", "sass", "scales", "stringi", "stringr", "systemfonts", "textshaping", "tidyr", "timechange", "timeDate", "tinytex", "tseries", "TTR", "utf8", "uuid", "vctrs", "vroom", "withr", "xfun", "xml2", "xts", "yaml"))
install.packages(c("BH", "bslib", "cli", "cpp11", "crosstalk", "curl", "data.table", "DBI", "dbplyr", "digest", "dplyr", "evaluate", "fansi", "future", "future.apply", "ggplot2", "glue", "haven", "htmltools", "htmlwidgets", "jsonlite", "knitr", "later", "lifecycle", "lubridate", "markdown", "openssl", "plotly", "prettyunits", "processx", "progress", "ps", "ragg", "Rcpp", "RcppArmadillo", "readr", "recipes", "reprex", "rlang", "sass", "scales", "stringi", "stringr", "systemfonts", "textshaping", "tidyr", "timechange", "timeDate", "tinytex", "tseries", "TTR", "utf8", "uuid", "vctrs", "vroom", "withr", "xfun", "xml2", "xts", "yaml"))
install.packages(c("BH", "bslib", "cli", "cpp11", "crosstalk", "curl", "data.table", "DBI", "dbplyr", "digest", "dplyr", "evaluate", "fansi", "future", "future.apply", "ggplot2", "glue", "haven", "htmltools", "htmlwidgets", "jsonlite", "knitr", "later", "lifecycle", "lubridate", "markdown", "openssl", "plotly", "prettyunits", "processx", "progress", "ps", "ragg", "Rcpp", "RcppArmadillo", "readr", "recipes", "reprex", "rlang", "sass", "scales", "stringi", "stringr", "systemfonts", "textshaping", "tidyr", "timechange", "timeDate", "tinytex", "tseries", "TTR", "utf8", "uuid", "vctrs", "vroom", "withr", "xfun", "xml2", "xts", "yaml"))
detach("package:stats", unload = TRUE)
detach("package:utils", unload = TRUE)
library(utils, lib.loc = "C:/Program Files/R/R-4.3.1/library")
detach("package:methods", unload = TRUE)
detach("package:graphics", unload = TRUE)
detach("package:grDevices", unload = TRUE)
detach("package:datasets", unload = TRUE)
install.packages("naniar")
dbinom(5, 10, 0.5)
dbinom(6, 10, 0.5)
dbinom(10, 10, 0.5)
p_value <- 1 - pnorm(2.15, mean = 127, sd = 39, lower.tail = FALSE)
p_value
# Define the t-value and degrees of freedom
t_value <- 3
df <- 2
# Find the cumulative probability up to the positive t-value
p_right_tail <- 1 - pt(t_value, df)
# Since the distribution is symmetric, the left tail area is the same as the right tail area
# Double the one tail area to get the total area outside plus/minus 3 units from the mean
total_tail_area <- 2 * p_right_tail
# Print the result
total_tail_area
t_value <- -1.79
df <- 19
p_right_tail <- 1-pt(t_value, df)
p_right_tail
0.069/sqrt(15)
2 * pt(1.47,99)
p_value <- 2 * (1 - pt(abs(1.47), 99))
p_value
# Values given in the problem
x_diff <- 12.76
SE_xdiff <- 1.67
df <- 72
# Calculating the t-score (already given in the problem as 7.65, but included here for completeness)
t_score <- (x_diff - 0) / SE_xdiff
# Calculating the p-value for a two-tailed test
p_value <- 2 * (1 - pt(abs(t_score), df))
# Output the t-score and p-value
print(paste("T-score:", t_score))
print(paste("P-value:", p_value))
install.packages("openintro")
install.packages("openintro")
install.packages("gss")
library(gss)
data(gss_all)
library(gss)
data(gss)
To generate a password meeting the specified requirements, we can break down the process into several steps:
# Define the password requirements
min_length <- 8
max_length <- 20
upper_case <- LETTERS
lower_case <- letters
numbers <- 0:9
special_chars <- c("!", "@", "$", "*", "+", "-")
max_repeating_chars <- 2
max_consecutive_numbers <- 8
email <- "example@example.com"
# Function to generate a random password
generate_password <- function() {
# Generate a random length between min_length and max_length
length <- sample(min_length:max_length, 1)
# Generate a random password string
password <- paste0(sample(c(upper_case, lower_case, numbers, special_chars), length, replace = TRUE), collapse = "")
return(password)
}
# Function to check if a password meets the requirements
check_requirements <- function(password) {
# Check length requirement
if (nchar(password) < min_length | nchar(password) > max_length) {
return(FALSE)
}
# Check if it contains upper case letters
if (!any(grepl("[A-Z]", password))) {
return(FALSE)
}
# Check if it contains lower case letters
if (!any(grepl("[a-z]", password))) {
return(FALSE)
}
# Check if it contains at least one number
if (!any(grepl("[0-9]", password))) {
return(FALSE)
}
# Check if it contains at least one special character
if (!any(grepl("[!@\\$*+\\-]", password))) {
return(FALSE)
}
# Check for repeating characters
if (any(gregexpr("(.)\\1{2,}", password)[[1]] != -1)) {
return(FALSE)
}
# Check for consecutive numbers
if (any(gregexpr("(0123456789){9,}", password)[[1]] != -1)) {
return(FALSE)
}
# Check if it contains the email address
if (grepl(email, password)) {
return(FALSE)
}
# If all requirements are met, return TRUE
return(TRUE)
}
# Generate and check password until all requirements are met
repeat {
password <- generate_password()
if (check_requirements(password)) {
break
}
}
# Output the final password
print(password)
install.packages("AppliedPredictiveModeling")
??AppliedPredictiveModeling
ls(AppliedPredictiveModeling)
ls("package:AppliedPredictiveModeling")
library(AppliedPredictiveModeling)
ls("package:AppliedPredictiveModeling")
library(help = "AppliedPredictiveModeling")
getPackages
ls(package = "AppliedPredictiveModeling")
ls(package:"AppliedPredictiveModeling")
ls("package:AppliedPredictiveModeling")
scriptLocation
reticulate::repl_python()
install datetime
pip install datetime
install_python(datetime)
library(reticulate)
reticulate
py_install(datetime)
# Confusion Matrix values
TP <- 268
FN <- 20
FP <- 5375
TN <- 23439
# Accuracy
accuracy <- (TP + TN) / (TP + TN + FP + FN)
print(paste("Accuracy:", accuracy))
# Sensitivity (Recall)
sensitivity <- TP / (TP + FN)
print(paste("Sensitivity:", sensitivity))
# Specificity
specificity <- TN / (TN + FP)
print(paste("Specificity:", specificity))
# Precision
precision <- TP / (TP + FP)
print(paste("Precision:", precision))
# Confusion Matrix values
TP <- 268
FN <- 20
FP <- 5375
TN <- 23439
# Accuracy
accuracy <- (TP + TN) / (TP + TN + FP + FN)
print(paste("Accuracy:", round(accuracy,2))
# Sensitivity (Recall)
sensitivity <- TP / (TP + FN)
# Confusion Matrix values
TP <- 268
FN <- 20
FP <- 5375
TN <- 23439
# Accuracy
accuracy <- (TP + TN) / (TP + TN + FP + FN)
print(paste("Accuracy:", round(accuracy,2))
# Sensitivity (Recall)
sensitivity <- TP / (TP + FN)
# Confusion Matrix values
TP <- 268
FN <- 20
FP <- 5375
TN <- 23439
# Accuracy
accuracy <- round(((TP + TN) / (TP + TN + FP + FN)),2)
print(paste("Accuracy:", accuracy))
# Sensitivity (Recall)
sensitivity <- round((TP / (TP + FN)), 2)
print(paste("Sensitivity:", sensitivity))
# Specificity
specificity <- round((TN / (TN + FP)),2)
print(paste("Specificity:", specificity))
# Precision
precision <- round((TP / (TP + FP)), 2)
print(paste("Precision:", precision))
library(ggplot2)
library(reshape2)
# Create confusion matrix data
conf_matrix <- matrix(c(TP, FN, FP, TN), nrow = 2, byrow = TRUE)
colnames(conf_matrix) <- c("Predicted Donation", "Predicted No Donation")
rownames(conf_matrix) <- c("Actual Donation", "Actual No Donation")
# Melt the data for ggplot
melted_conf_matrix <- melt(conf_matrix)
# Plot heatmap
ggplot(data = melted_conf_matrix, aes(x = Var2, y = Var1, fill = value)) +
geom_tile() +
geom_text(aes(label = value), color = "white", size = 6) +
scale_fill_gradient(low = "white", high = "blue") +
labs(title = "Confusion Matrix Heatmap", x = "Predicted", y = "Actual")
library(ggplot2)
library(reshape2)
# Create confusion matrix data
conf_matrix <- matrix(c(TP, FN, FP, TN), nrow = 2, byrow = TRUE)
colnames(conf_matrix) <- c("Predicted Donation", "Predicted No Donation")
rownames(conf_matrix) <- c("Actual Donation", "Actual No Donation")
# Melt the data for ggplot
melted_conf_matrix <- melt(conf_matrix)
# Plot heatmap
ggplot(data = melted_conf_matrix, aes(x = Var2, y = Var1, fill = value)) +
geom_tile() +
geom_text(aes(label = value), color = "black", size = 6) +
scale_fill_gradient(low = "white", high = "blue") +
labs(title = "Confusion Matrix Heatmap", x = "Predicted", y = "Actual")
library(ggplot2)
library(reshape2)
# Create confusion matrix data
conf_matrix <- matrix(c(TP, FN, FP, TN), nrow = 2, byrow = TRUE)
colnames(conf_matrix) <- c("Predicted Donation", "Predicted No Donation")
rownames(conf_matrix) <- c("Actual Donation", "Actual No Donation")
# Melt the data for ggplot
melted_conf_matrix <- melt(conf_matrix)
# Plot heatmap
ggplot(data = melted_conf_matrix, aes(x = Var2, y = Var1, fill = value)) +
geom_tile() +
geom_text(aes(label = value), color = "black", size = 6) +
scale_fill_gradient(low = "white", high = "blue") +
labs(title = "Figure 1: Confusion Matrix Heatmap", x = "Predicted", y = "Actual")
# Probabilities
P_s1 <- 0.3  # Zoning approved
P_s2 <- 0.7  # Zoning rejected
# Market research accuracies
P_A_given_s1 <- 0.9  # Predict Approval given Approval
P_N_given_s1 <- 0.1  # Predict Rejection given Approval
P_A_given_s2 <- 0.2  # Predict Approval given Rejection
P_N_given_s2 <- 0.8  # Predict Rejection given Rejection
# Total probabilities
P_A <- P_A_given_s1 * P_s1 + P_A_given_s2 * P_s2  # Probability Predict Approval
P_N <- 1 - P_A  # Probability Predict Rejection
# Posterior probabilities using Bayes' theorem
P_s1_given_A <- (P_A_given_s1 * P_s1) / P_A  # Probability Approval given Predict Approval
P_s1_given_N <- (P_N_given_s1 * P_s1) / P_N  # Probability Approval given Predict Rejection
# Expected Monetary Value calculations
# EMV without market research
EMV_no_research <- 0.2 * (0.3 * 2000000 + 0.7 * (-500000))
# EMV with market research
# If market research predicts approval
EMV_predict_approval <- 0.2 * (P_s1_given_A * 2000000 + (1 - P_s1_given_A) * (-500000))
# If market research predicts rejection
EMV_predict_rejection <- 0.2 * (P_s1_given_N * 2000000 + (1 - P_s1_given_N) * (-500000))
# Expected EMV with market research before cost
EMV_with_research_before_cost <- P_A * EMV_predict_approval + P_N * EMV_predict_rejection
# Net EMV after subtracting the cost of market research
EMV_with_research <- EMV_with_research_before_cost - 15000
# Expected Value of Sample Information
EVSI <- EMV_with_research - EMV_no_research
# Output the results
cat("EMV without market research: $", EMV_no_research, "\n")
cat("EMV with market research: $", EMV_with_research, "\n")
cat("Expected Value of Sample Information (EVSI): $", EVSI, "\n")
generate_password <- function(length = 12) {
if (length < 4) {
stop("Password length must be at least 4 to include all character types.")
}
# Character sets
lowercase <- letters
uppercase <- LETTERS
digits <- 0:9
special <- c("!", "#", "$", "%", "&", "(", ")", "*", "+", "-", "/", ":", ";", "<", "=", ">", "?", "@", "[", "^", "_", "{", "|", "}", "~")
# Ensure inclusion of at least one character from each set
password_chars <- c(
sample(lowercase, 1),
sample(uppercase, 1),
sample(digits, 1),
sample(special, 1)
)
# Fill the remaining length with random characters from all sets combined
all_chars <- c(lowercase, uppercase, digits, special)
remaining_length <- length - 4
password_chars <- c(password_chars, sample(all_chars, remaining_length, replace = TRUE))
# Shuffle the characters
password_chars <- sample(password_chars)
# Combine into a single string
password <- paste(password_chars, collapse = "")
return(password)
}
# Example usage
set.seed(123)  # Setting seed for reproducibility
generate_password(20)
generate_password <- function(length = 12) {
if (length < 5) {
stop("Password length must be at least 5 to include all character types with the given constraints.")
}
# Character sets
lowercase <- letters
uppercase <- LETTERS
digits <- as.character(0:9)
special <- c("!", "#", "$", "%", "&", "(", ")", "*", "+", "-", "/", ":", ";", "<", "=", ">", "?", "@", "[", "^", "_", "{", "|", "}", "~")
# Determine the number of special characters (at least 1, but no more than 20% of the total length)
max_specials <- floor(length * 0.2)
num_specials <- sample(1:max_specials, 1)
# Ensure inclusion of at least one character from each non-special set
password_chars <- c(
sample(lowercase, 1),
sample(uppercase, 1),
sample(digits, 1),
sample(special, num_specials)
)
# Calculate remaining characters needed
remaining_length <- length - length(password_chars)
# Fill the remaining length with random characters from all non-special sets combined
all_non_specials <- c(lowercase, uppercase, digits)
password_chars <- c(password_chars, sample(all_non_specials, remaining_length, replace = TRUE))
# Shuffle the characters
password_chars <- sample(password_chars)
# Combine into a single string
password <- paste(password_chars, collapse = "")
return(password)
}
# Example usage
set.seed(123)  # Setting seed for reproducibility
generate_password(32)
getRversion()
getRversion()
getRversion()
install.packages("languageserver")
install.packages("radian")
install.packages("VSCode-R-Debugger")
install.packages("httpgd")
R.home()
library(tidyverse)
p <- ggplot(iris, aes(x = Sepal.Width))
p + geom_histogram()
p <- ggplot(iris, aes(x = Sepal.Width))
p + geom_histogram()
p + geom_bar()
p <- ggplot(mtcars, aes(x = factor(cyl),  fill = factor(am)))
p + geom_bar()
p + stat_count()
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
geom_point() +
stat_smooth()
# geom_smooth() using method = 'loess' and formula 'y ~ x'
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
geom_point() +
stat_smooth(se = FALSE)
# geom_smooth() using method = 'loess' and formula 'y ~ x'
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
geom_point() +
stat_smooth(se = FALSE, span = 0.4)
# geom_smooth() using method = 'loess' and formula 'y ~ x'
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
geom_point() +
stat_smooth(method = "lm", se = FALSE)
ggplot(iris, aes(x = Sepal.Length,
y = Sepal.Width,
color = Species)) +
geom_point() +
geom_smooth(method = "lm",
fullrange = TRUE)
p <- ggplot(iris, aes(Sepal.Length, Sepal.Width))
p + geom_point() + ggtitle("Low precision (& integer) data")
p + geom_jitter(alpha = 0.5,
width = 0.1,
height = 0.1) +
ggtitle("Jittering may give a wrong impression")
p + geom_count() + ggtitle("geom_count()")
setwd("//wdmycloudex4100/Axl-Ibiza/Andrex_Ibiza/Notes-and-Study-Guides/DataCamp_Intermediate-Data-Visualization-with-ggplot2")
ls
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
geom_point() +
stat_smooth(se = FALSE)
# geom_smooth() using method = 'loess' and formula 'y ~ x'
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
geom_point() +
stat_smooth(se = FALSE, span = 0.4)
# geom_smooth() using method = 'loess' and formula 'y ~ x'
ggplot(mtcars, aes(x = wt, y = mpg)) +
geom_point() +
# Add 3 smooth LOESS stats, varying span & color
stat_smooth(color = "red", span = 0.9, se = FALSE) +
stat_smooth(color = "green", span = 0.6, se = FALSE) +
stat_smooth(color = "blue", span = 0.3, se = FALSE)
p <- ggplot(iris, aes(Sepal.Length, Sepal.Width))
p + geom_point() + ggtitle("Low precision (& integer) data")
p + geom_jitter(alpha = 0.5,
width = 0.1,
height = 0.1) +
ggtitle("Jittering may give a wrong impression")
p + geom_count() + ggtitle("geom_count()")
ggplot(iris, aes(x = Species,
y = Sepal.Length)) +
geom_jitter(width = 0.2)
set.seed(123)
xx <- rnorm(100)
mean(xx)
mean(xx) + (sd(xx) * c(-1, 1))
smean.sdl(xx, mult = 1)
# Hmisc
library(Hmisc)
smean.sdl(xx, mult = 1)
# ggplot2
mean_sdl(xx, mult = 1)
