---
title: "DataCamp_Intermediate-Data-Visualization-with-ggplot2"
output: html_notebook
student: "Andrex Ibiza, MBA"
date: 2025-02-11
---

# Chapter 1: Statistics

A picture paints a thousand words, which is why R ggplot2 is such a powerful tool for graphical data analysis. In this chapter, youâ€™ll progress from simply plotting data to applying a variety of statistical methods. These include a variety of linear models, descriptive and inferential statistics (mean, standard deviation and confidence intervals) and custom functions.

## Video 1.1: Stats with geoms

### ggplot2, course 2

-   Statistics
-   Coordinates
-   Facets
-   Data Visualization Best Practices

### Statistics layer

-   Two categories of functions:
    -   Called from within a geom
    -   Called independently
-   `stats_` : all statistical functions begin with this prefix.
    -   even from within the geom layer, they can be called independently in this way.

### `geom_` \<-\> `stat_`

```{r}
library(tidyverse)
p <- ggplot(iris, aes(x = Sepal.Width))
p + geom_histogram()
```

```{r}
p <- ggplot(iris, aes(x = Sepal.Width))
p + geom_histogram()
p + geom_bar()
```

```{r}
p <- ggplot(mtcars, aes(x = factor(cyl),  fill = factor(am)))
p + geom_bar()
p + stat_count()
```

| `stat_`        | `geom_`                               |
|----------------|---------------------------------------|
| `stat_bin`     | `geom_histogram()`, `geom_freqpoly()` |
| `stat_count()` | `geom_bar()`                          |

### `stat_smooth()`

```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point() +
  stat_smooth()

# geom_smooth() using method = 'loess' and formula 'y ~ x'
```

### `stat_smooth(se = FALSE)`

```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point() +
  stat_smooth(se = FALSE)

# geom_smooth() using method = 'loess' and formula 'y ~ x'
# loess is a nonparametric smoothing algorithm used when there are less than 1000 observations. creates weighted mean that creates sliding window along x-axis and is valuable for exploratory data analysis.
```

### `geom_smooth(span = 0.4)`

```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point() +
  stat_smooth(se = FALSE, span = 0.4)

# geom_smooth() using method = 'loess' and formula 'y ~ x'
# the `span` argument controls the degree of smoothing, which is the size of the sliding window.
```

### `geom_smooth(method = "lm")`

```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point() +
  stat_smooth(method = "lm", se = FALSE)
```

### `geom_smooth(fullrange = TRUE)`

```{r}
ggplot(iris, aes(x = Sepal.Length,
                 y = Sepal.Width,
                 color = Species)) +
  geom_point() +
  geom_smooth(method = "lm", 
              fullrange = TRUE)
```

| `stat_` | `geom_` |
|------------------------------------|------------------------------------|
| `stat_bin` | `geom_histogram()`, `geom_freqpoly() | |`stat_count()`|`geom_bar()`| |`stat_smooth()`|`geom_smooth()\` |

### Other `stat_` functions

| `stat_`           | `geom_`           |
|-------------------|-------------------|
| `stat_boxplot()`  | `geom_boxplot()`  |
| `stat_bindot()`   | `geom_dotplot()`  |
| `stat_bin2d()`    | `geom_bin2d()`    |
| `stat_binhex()`   | `geom_hex()`      |
| `stat_contour()`  | `geom_contour()`  |
| `stat_quantile()` | `geom_quantile()` |
| `stat_sum()`      | `geom_count()`    |

### Exercise: Modifying `stat_smooth`

In the previous exercise we used `se = FALSE` in `stat_smooth()` to remove the 95% Confidence Interval. Here we'll consider another argument, span, used in LOESS smoothing, and we'll take a look at a nice scenario of properly mapping different models.

#### Instructions 1/3
33 XP
Explore the effect of the span argument on LOESS curves. Add three smooth LOESS stats, each without the standard error ribbon.

Color the 1st one "red"; set its span to 0.9.
Color the 2nd one "green"; set its span to 0.6.
Color the 3rd one "blue"; set its span to 0.3.
Compare LOESS and linear regression smoothing on small regions of data.
```{r}
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  # Add 3 smooth LOESS stats, varying span & color
  stat_smooth(color = "red", span = 0.9, se = FALSE) +
  stat_smooth(color = "green", span = 0.6, se = FALSE) +
  stat_smooth(color = "blue", span = 0.3, se = FALSE)
```

#### 2/3
Add a smooth LOESS stat, without the standard error ribbon.
Add a smooth linear regression stat, again without the standard error ribbon.
```{r}
# Amend the plot to color by fcyl
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  # Add a smooth LOESS stat, no ribbon
  stat_smooth(se = FALSE) +
  # Add a smooth lin. reg. stat, no ribbon
  stat_smooth(method = "lm", se = FALSE)
```


#### 3/3
LOESS isn't great on very short sections of data; compare the pieces of linear regression to LOESS over the whole thing.

Amend the smooth LOESS stat to map color to a dummy variable, "All".
```{r}
# Amend the plot
# ggplot(mtcars, aes(x = wt, y = mpg, color = cyl)) +
#   geom_point() +
#   # Map color to dummy variable "All"
#   stat_smooth(aes(color = "All"), se = FALSE) +
#   stat_smooth(method = "lm", se = FALSE)
```

### Smoothing
Smoothing
To practice on the remaining layers (statistics, coordinates and facets), we'll continue working on several datasets from the first course.

The mtcars dataset contains information for 32 cars from Motor Trends magazine from 1974. This dataset is small, intuitive, and contains a variety of continuous and categorical (both nominal and ordinal) variables.

In the previous course you learned how to effectively use some basic geometries, such as point, bar and line. In the first chapter of this course you'll explore statistics associated with specific geoms, for example, smoothing and lines.

#### Instructions 1/4
25 XP
Look at the structure of mtcars.
Using mtcars, draw a scatter plot of mpg vs. wt.
```{r}
# View the structure of mtcars
str(mtcars)

# Using mtcars, draw a scatter plot of mpg vs. wt
ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
```
#### 2/4
Update the plot to add a smooth trend line. Use the default method, which uses the LOESS model to fit the curve.
```{r}
# Amend the plot to add a smooth layer
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  geom_smooth()
```
#### 3/4
Update the smooth layer. Apply a linear model by setting method to "lm", and turn off the model's 95% confidence interval (the ribbon) by setting se to FALSE.
```{r}
# Amend the plot. Use lin. reg. smoothing; turn off std err ribbon
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```
#### 4/4
Draw the same plot again, swapping geom_smooth() for stat_smooth().
```{r}
# Amend the plot. Swap geom_smooth() for stat_smooth().
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  stat_smooth(method = "lm", se = FALSE)
```
### Grouping Variables
We'll continue with the previous exercise by considering the situation of looking at sub-groups in our dataset. For this we'll encounter the invisible group aesthetic.

mtcars has been given an extra column, fcyl, that is the cyl column converted to a proper factor variable.

Instructions 1/2
50 XP
Using mtcars, plot mpg vs. wt, colored by fcyl.
Add a point layer.
Add a smooth stat using a linear model, and don't show the se ribbon.

```{r}
# Using mtcars, plot mpg vs. wt, colored by fcyl
ggplot(mtcars, aes(x = wt, y = mpg, color = cyl)) +
  # Add a point layer
  geom_point() +
  # Add a smooth lin reg stat, no ribbon
  stat_smooth(method = "lm", se = FALSE)
```
```{r}
# Amend the plot to add another smooth layer with dummy grouping
ggplot(mtcars, aes(x = wt, y = mpg, color = cyl)) +
  geom_point() +
  stat_smooth(method = "lm", se = FALSE) +
  stat_smooth(aes(group = 1), method = "lm", se = FALSE)
```



## Video 1.2: Stats: sum and quantile

### Recall from course 1

|   | Cause of Over-plotting | Solutions |
|--------------|-----------------------------|-----------------------------|
| 1 | Large datasets | Alpha-blending, hollow circles, and point size |
| 2 | Aligned values on a single axis | As above, plus change position |
| 3 | Low-precision data | Position: jitter |
| 4 | Integer data | Position: jitter |

### Plot counts to overcome over-plotting

|   | Cause of Over-plotting | Solutions | Here |
|---------------|-------------------|-------------------|-------------------|
| 1 | Large datasets | Alpha-blending, hollow circles, and point size |  |
| 2 | Aligned values on a single axis | As above, plus change position |  |
| 3 | Low-precision data | Position: jitter | `geom_count()` |
| 4 | Integer data | Position: jitter | `geom_count()` |

### Low precision (& integer) data

```{r}
p <- ggplot(iris, aes(Sepal.Length, Sepal.Width))
p + geom_point() + ggtitle("Low precision (& integer) data")
```

### Jittering may give a wrong impression

```{r}
p + geom_jitter(alpha = 0.5,
                width = 0.1,
                height = 0.1) +
  ggtitle("Jittering may give a wrong impression")
```

### `geom_count()`

```{r}
p + geom_count() + ggtitle("geom_count()")
```
## Video 1.3: Stats outside geoms

### Basic plot
```{r}
ggplot(iris, aes(x = Species,
                 y = Sepal.Length)) +
  geom_jitter(width = 0.2)
```
### Calculating statistics
```{r}
set.seed(123)
xx <- rnorm(100)
mean(xx)
```
```{r}
mean(xx) + (sd(xx) * c(-1, 1))
```
```{r}
# Hmisc
library(Hmisc)
smean.sdl(xx, mult = 1)
```
```{r}
# ggplot2
mean_sdl(xx, mult = 1)
```
### `stat_summary()`
* Uses `geom_pointrange()` by default

```{r}
ggplot(iris, aes(x = Species,
                 y = Sepal.Length)) +
  stat_summary(fun.data = mean_sdl,
               fun.args = list(mult = 1))
```

```{r}
ggplot(iris, aes(x = Species,                 
                 y = Sepal.Length)) +  
  stat_summary(fun = mean,               
               geom = "point") +  
  stat_summary(fun.data = mean_sdl,               
               fun.args = list(mult =1),               
               geom = "errorbar",               
               width = 0.1)
```

### 95% confidence interval
```{r}
ERR <- qt(0.975, length(xx) - 1) * sd(xx) / sqrt(length(xx))
mean(xx)
# [1] 0.09040591

mean(xx) + (ERR * c(-1, 1)) # 95% CI
# [1] -0.09071657  0.27152838

mean_cl_normal(xx)
```
### Other `stat_` functions

| `stat_`           | Description           |
| ------------------|-----------------------|
| `stat_summary()`  | Summarize y values at distinct x values    |
| `stat_function()` | Compute y values from a function of x values |
| `stat_qq()`       | Perform calculations for a quantile-quantile plot |


### Normal distribution
```{r}
library(MASS)
mam.new <- data.frame(body = log10(mammals$body))

ggplot(mam.new, aes(x = body)) +
  geom_histogram(aes(y = ..density..)) +
  geom_rug() +
  stat_function(fun = dnorm, color = "red", args = list(mean = mean(mam.new$body), 
                                                        sd = sd(mam.new$body)))
```

### Quantile-quantile (QQ) plot
```{r}
ggplot(mam.new, aes(sample = body)) +
  stat_qq() +
  geom_qq_line(col = "red")
```
#### Preparations
In the following exercises, we'll aim to make the plot shown in the viewer. Here, we'll establish our positions and base layer of the plot.

Establishing these items as independent objects will allow us to recycle them easily in many layers, or plots.

* `position_jitter()` adds jittering (e.g. for points).
* `position_dodge()` dodges geoms, (e.g. bar, col, boxplot, violin, errorbar, pointrange).
* `position_jitterdodge()` jitters and dodges geoms, (e.g. points).
As before, we'll use `mtcars`, where `fcyl` and `fam` are proper factor variables of the original `cyl` and `am` variables.

##### Instructions 1/2
50 XP
1/2
Using these three functions, define these position objects:
* `posn_j`: will jitter with a width of 0.2.
* `posn_d`: will dodge with a width of 0.1.
* `posn_jd` will jitter and dodge with a jitter.width of 0.2 and a dodge.width of 0.1.

```{r}
# Define position objects
# 1. Jitter with width 0.2
posn_j <- position_jitter(width = 0.2)

# 2. Dodge with width 0.1
posn_d <- position_dodge(width = 0.1)

# 3. Jitter-dodge with jitter.width 0.2 and dodge.width 0.1
posn_jd <- position_jitterdodge(jitter.width = 0.2, dodge.width = 0.1)
```

##### Instructions 2/2
50 XP
2/2

Plot `wt` vs. `fcyl`, colored by `fam`. Assign this base layer to `p_wt_vs_fcyl_by_fam`.

Plot the data using `geom_point()`.
```{r}
# From previous step
posn_j <- position_jitter(width = 0.2)
posn_d <- position_dodge(width = 0.1)
posn_jd <- position_jitterdodge(jitter.width = 0.2, dodge.width = 0.1)

# Create the plot base: wt vs. fcyl, colored by fam
p_wt_vs_fcyl_by_fam <- ggplot(mtcars, aes(x = cyl, y = wt, color = am))

# Add a point layer
p_wt_vs_fcyl_by_fam +
  geom_point()
```
### Using position objects

Now that the position objects have been created, you can apply them to the base plot to see their effects. You do this by adding a point geom and setting the position argument to the position object.

The variables from the last exercise, posn_j, posn_d, posn_jd, and p_wt_vs_fcyl_by_fam are available in your workspace.

##### Instructions 1/3
35 XP
Apply the jitter position, posn_j, to the base plot.

```{r}
# Add jittering only
p_wt_vs_fcyl_by_fam_jit <- p_wt_vs_fcyl_by_fam +
  geom_point(position = posn_j)
p_wt_vs_fcyl_by_fam_jit
```

2/3
Apply the dodge position, posn_d, to the base plot.
```{r}
# Add dodging only
p_wt_vs_fcyl_by_fam +
  geom_point(position = posn_d)
```

3/3
Apply the jitter-dodge position, posn_jd, to the base plot.

```{r}
# Add jittering and dodging
p_wt_vs_fcyl_by_fam +
  geom_point(position = posn_jd)
```

### Plotting variations

The preparation is done; now let's explore stat_summary().

Summary statistics refers to a combination of location (mean or median) and spread (standard deviation or confidence interval).

These metrics are calculated in stat_summary() by passing a function to the fun.data argument. mean_sdl(), calculates multiples of the standard deviation and mean_cl_normal() calculates the t-corrected 95% CI.

Arguments to the data function are passed to stat_summary()'s fun.args argument as a list.

The position object, posn_d, and the plot with jittered points, p_wt_vs_fcyl_by_fam_jit, are available.

#### Instructions 1/3
33 XP
Add error bars representing the standard deviation.
Set the data function to mean_sdl (without parentheses).
Draw 1 standard deviation each side of the mean, pass arguments to the mean_sdl() function by assigning them to fun.args in the form of a list.
Use posn_d to set the position.

```{r}
p_wt_vs_fcyl_by_fam_jit + 
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), position = posn_d)
```
##### 2/2
The default geom for stat_summary() is "pointrange" which is already great.

Update the summary stat to use an "errorbar" geom by assigning it to the geom argument.
```{r}
p_wt_vs_fcyl_by_fam_jit +
  # Change the geom to be an errorbar
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), position = posn_d, geom = "errorbar")
```

##### 3/3
Update the plot to add a summary stat of 95% confidence limits.
Set the data function to mean_cl_normal (without parentheses).
Again, use the dodge position.
```{r}
p_wt_vs_fcyl_by_fam_jit +
  # Add a summary stat of normal confidence limits
  stat_summary(fun.data = mean_cl_normal,
  fun.args = list(mult = 1),
  geom = "errorbar",
  position = posn_d)
```


# Chapter 2: Coordinates

## Video 2.1: Coordinates

### Coordinates layer
* Controls plot dimensions
* `coord_`
    * e.g. `coord_cartesian()`, `coord_flip()`, `coord_polar()` 

### Zooming in
* We use `coord_cartesian()` to zoom in on a specific part of a plot.
* `coord_cartesian(xlim = ...)`
* `scale_x_continuous(limits = ...)`
* `xlim(...)`
* `ylim(...)`

### Original plot
```{r}
iris.smooth <- ggplot(
  iris,
  aes(x = Sepal.Length,
      y = Sepal.Width,
      color = Species)
) +
  geom_point(alpha = 0.7) +
  geom_smooth()

iris.smooth
```

### `scale_x_continuous()`
```{r}
iris.smooth +
  scale_x_continuous(limits = c(4.5, 5.5))
```
Important warning messages: 95 rows removed bc they were a smaller range than the data and were filtered out.


### `xlim()`
- A quick and dirty alternative is to call `xlim()` as a function itself.
```{r}
iris.smooth +
  xlim(c(4.5, 5.5))
```
This has the same effect.

### `coord_cartesian()`
```{r}
iris.smooth +
  coord_cartesian(xlim = c(4.5, 5.5))
```

Don't recycle or hard code limits before seeing the actual data.

### Aspect ratio
- Height-to-width ratio
- Watch out for deceiption!
- No universal standard
- Typically use 1:1 if data is on the same scale.

### Sunspots
```{r}
library(zoo)
sunspots.m <- data.frame(
  year = index(sunspot.month),
  value = reshape2::melt(sunspot.month)$value)

ggplot(sunspots.m, aes(
  x = year,
  y = value
)) +
  geom_line() +
  coord_fixed() # default to 1:1 aspect ratio
```

```{r}
ggplot(sunspots.m, aes(x = year, y = value)) +
  geom_line() +
  coord_fixed(ratio = 0.055)
```

## Zooming In

In the video, you saw different ways of using the coordinates layer to zoom in. In this exercise, we'll compare zooming by changing scales and by changing coordinates.

The big difference is that the scale functions change the underlying dataset, which affects calculations made by computed geoms (like histograms or smooth trend lines), whereas coordinate functions make no changes to the dataset.

A scatter plot using mtcars with a LOESS smoothed trend line is provided. Take a look at this before updating it.

### Instructions 1/2
50 XP
Update the plot by adding (+) a continuous x scale with limits from 3 to 6. 
Spoiler: this will cause a problem!

```{r}
# # Run the code, view the plot, then update it
# ggplot(mtcars, aes(x = wt, y = hp, color = fam)) +
#   geom_point() +
#   geom_smooth() +
#   # Add a continuous x scale from 3 to 6
#   scale_x_continuous(limits = c(3, 6))
```
### 2/2
Update the plot by adding a Cartesian coordinate system with x limits, xlim, from 3 to 6.

```{r}
ggplot(mtcars, aes(x = wt, y = hp, color = am)) +
  geom_point() +
  geom_smooth() +
  # Add Cartesian coordinates with x limits from 3 to 6
  coord_cartesian(xlim = c(3,6))
```

## Aspect ratio I: 1:1 ratios
We can set the aspect ratio of a plot with coord_fixed(), which uses ratio = 1 as a default. A 1:1 aspect ratio is most appropriate when two continuous variables are on the same scale, as with the iris dataset.

All variables are measured in centimeters, so it only makes sense that one unit on the plot should be the same physical distance on each axis. This gives a more truthful depiction of the relationship between the two variables since the aspect ratio can change the angle of our smoothing line. This would give an erroneous impression of the data. Of course the underlying linear models don't change, but our perception can be influenced by the angle drawn.

A plot using the iris dataset, of sepal width vs. sepal length colored by species, is shown in the viewer.

### Instructions
100 XP
Add a fixed coordinate layer to force a 1:1 aspect ratio.

```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_jitter() +
  geom_smooth(method = "lm", se = FALSE) +
  # Fix the coordinate ratio
  coord_fixed()
```
## Expand and clip
The `coord_*()` layer functions offer two useful arguments that work well together: `expand` and `clip`.

`expand` sets a buffer margin around the plot, so data and axes don't overlap. Setting `expand` to `0` draws the axes to the limits of the data.
`clip` decides whether plot elements that would lie outside the plot panel are displayed or ignored ("clipped").
When done properly this can make a great visual effect! We'll use `theme_classic()` and modify the axis lines in this example.

### Instructions 1/2
50 XP
1
Add Cartesian coordinates with zero expansion, to remove all buffer margins on both the x and y axes.

```{r}
ggplot(mtcars, aes(wt, mpg)) +
  geom_point(size = 2) +
  # Add Cartesian coordinates with zero expansion
  coord_cartesian(expand = 0) +
  theme_classic()
```


### 2/2
Setting `expand` to `0` caused points at the edge of the plot panel to be cut off.

Set the `clip` argument to "off" to prevent this.
Remove the axis lines by setting the axis.line argument to `element_blank()` in the `theme()` layer function.
```{r}
ggplot(mtcars, aes(wt, mpg)) +
  geom_point(size = 2) +
  # Turn clipping off
  coord_cartesian(expand = 0, clip = "off") +
  theme_classic() +
  # Remove axis lines
  theme(axis.line = element_blank())
```
## Video 2.2: Coordinates vs. scales
- How to use the coordinate layer to perform transformations, and 
- How that differs from using the scale functions. 

### Plot the raw data
```{r}
ggplot(msleep, aes(x = bodywt, y = 1)) +
  geom_jitter() +
  scale_x_continuous(limits = c(0, 7000),
                     breaks = seq(0, 7000, 1000))
```
### Transform the raw data
```{r}
ggplot(msleep, aes(log10(bodywt), y = 1)) +
  geom_jitter() +
  scale_x_continuous(limits = c(-3, 4),
                     breaks = seq(-3, 4),
  )
```
### Add `logtick` annotation
```{r}
ggplot(msleep, aes(log10(bodywt), y = 1)) +
  geom_jitter() +
  scale_x_continuous(limits = c(-3, 4),
                     breaks = -3:4) +
                     annotation_logticks(sides = "b") # highlights log transformation
```
Another solution is to have the data on a log scale and label it with the original body weight value. Two ways to do this.

### Use `scale_*_log10()`
```{r}
ggplot(msleep, aes(bodywt, y = 1)) +
  geom_jitter() +
  scale_x_log10(limits = c(1e-03, 1e+04))
```
### Use `coord_trans()`
```{r}
ggplot(msleep, aes(bodywt, y = 1)) +
  geom_jitter() +
  coord_trans(x = "log10")
```

Using `coord_trans` and setting the x argument to `log10` results in the same plot as using `scale_x_log10`. The default labels are different, but the plot is the same. But, there are some fundamental differences under the hood when applying transformations.


## Log-transforming scales

Using `scale_y_log10()` and `scale_x_log10()` is equivalent to transforming our actual dataset before getting to `ggplot2`.

Using `coord_trans()`, setting `x = "log10"` and/or `y = "log10"` arguments, transforms the data after statistics have been calculated. The plot will look the same as with using `scale_*_log10()`, but the scales will be different, meaning that we'll see the original values on our log10 transformed axes. This can be useful since log scales can be somewhat unintuitive.

Let's see this in action with positively skewed data - the brain and body weight of 51 mammals from the msleep dataset.

### Instructions 1/3
Using the msleep dataset, plot the raw values of brainwt against bodywt values as a scatter plot.
```{r}
# Produce a scatter plot of brainwt vs. bodywt
ggplot(msleep, aes(x = bodywt, y = brainwt)) +
  geom_point() +
  ggtitle("Raw Values")
```



### Instructions 2/3
Add the scale_x_log10() and scale_y_log10() layers with default values to transform the data before plotting.
```{r}
# Add scale_*_*() functions
ggplot(msleep, aes(bodywt, brainwt)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  ggtitle("Scale_ functions")
```


### Instructions 3/3
Use `coord_trans()` to apply a `"log10"` transformation to both the `x` and `y` scales.
```{r}
# Perform a log10 coordinate system transformation
ggplot(msleep, aes(bodywt, brainwt)) +
  geom_point() +
  coord_trans(x = "log10", y = "log10")
```

## Adding stats to transformed scales

In the last exercise, we saw the usefulness of the coord_trans() function, but be careful! Remember that statistics are calculated on the untransformed data. A linear model may end up looking not-so-linear after an axis transformation. Let's revisit the two plots from the previous exercise and compare their linear models.

### Instructions 1/2
Add `log10` transformed scales to the `x` and `y` axes.
```{r}
# Plot with a scale_*_*() function:
ggplot(msleep, aes(bodywt, brainwt)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  # Add a log10 x scale
  scale_x_log10() +
  # Add a log10 y scale
  scale_y_log10() +
  ggtitle("Scale functions")
```


### 2/2
Add a `log10` coordinate transformation for both the `x` and `y` axes.
Do you notice the difference between the two plots?
```{r}
# Plot with transformed coordinates
ggplot(msleep, aes(bodywt, brainwt)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  # Add a log10 coordinate transformation for x and y axes
  coord_trans(x = "log10", y = "log10")
```
## Video 2.3: Double and flipped axes

### Typical axis modifications
- Aspect ratios (see video 1)
    - Adjust for best perspective 
- Transformation functions (e.g. log, see video 2)
    - Adjust if original scale is inappropriate.
- Double x or y axes
    - Add raw and transformed values
    - Actually, having a double x or y axis is strongly discouraged.
    - One problem with presenting transformed values is that we are an additional step further removed from the raw data.
- Flipped axes
    - Change direction of dependencies
    - Change geometry orientation

### Flipping axes
```{r}
ggplot(iris, aes(x = Sepal.Length, 
                 y = Sepal.Width,
                 color = Species)) +
  geom_point() +
  geom_smooth(method = "lm", 
              se = FALSE)
```
### `coord_flip()`







